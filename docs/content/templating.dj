---
title: Templating
weight: 80
group: Templating
---
# Templating

Glaze uses [Sugar](https://josbeir.github.io/sugar/) for page rendering -- a PHP template engine with inheritance, blocks, components, and directives.

Templates live in `templates/` and use the `.sugar.php` extension. Sugar automatically escapes output based on context (HTML, attribute, URL, JS, CSS), so you do not need a manual `htmlspecialchars()` call for most values.

This page covers Glaze-specific integration. For the full directive and language reference, see the [Sugar documentation](https://josbeir.github.io/sugar/).

## Template inheritance

Sugar uses `s:extends` and `s:block` for layout inheritance. A base layout defines named blocks; child templates fill them in.

`templates/layout/base.sugar.php`:

```php
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title s:block="title"><?= $site->title ?></title>
</head>
<body>
    <main s:block="content"></main>
</body>
</html>
```

`templates/page.sugar.php`:

```php
<s-template s:extends="layout/base">

<title s:prepend="title"><?= $page->title ?> | </title>

<s-template s:block="content">
    <article>
        <h1><?= $page->title ?></h1>
        <?= $content |> raw() ?>
    </article>
</s-template>
```

The `|> raw()` pipe disables escaping for the rendered `$content` HTML. All other output is escaped automatically by Sugar.

For full inheritance options (`s:prepend`, `s:append`, `s:block` nesting), see the [Sugar inheritance docs](https://josbeir.github.io/sugar/guide/templates/inheritance.html).

## Per-page template override

Override the template for a single page in frontmatter:

```djot
---
title: Landing page
template: landing
---
```

This renders the page with `templates/landing.sugar.php` instead of the configured default.

## Available variables

These variables are injected into every page template by Glaze:

| Variable | Type | Description |
| --- | --- | --- |
| `$title` | `string` | Page title |
| `$content` | `string` | Rendered Djot HTML |
| `$url` | `string` | Current URL path |
| `$page` | `ContentPage` | Full page object |
| `$meta` | `array` | Merged page metadata |
| `$site` | `SiteConfig` | Global site config |

### `$page` properties

```php
$page->title            // string
$page->urlPath          // string -- e.g. /blog/my-post/
$page->slug             // string -- e.g. blog/my-post
$page->relativePath     // string -- e.g. blog/my-post.dj
$page->source           // string -- raw Djot source
$page->draft            // bool
$page->type             // ?string -- resolved content type name
$page->meta             // array<string, mixed> -- all frontmatter metadata (keys lowercased)
$page->taxonomies       // array<string, array<string>>
$page->toc              // list<TocEntry> -- TOC entries collected during rendering (empty until rendered)

$page->meta('hero.title')                  // dotted access to nested frontmatter
$page->meta('hero.primaryAction.href', '/') // dotted access with default fallback
$page->hasMeta('hero.highlights')          // existence check
```

### `$site` properties

```php
$site->title            // ?string
$site->description      // ?string
$site->baseUrl          // ?string
$site->basePath         // ?string -- e.g. /blog for subfolder deploys

$site->meta('hero.title')                 // dotted access to custom site.* config keys
$site->siteMeta('hero.title')             // alias for readability
$site->hasSiteMeta('hero.primaryAction')  // existence check
```

## Site context (`$this`)

Inside every template, `$this` is a `SiteContext` instance with helpers for querying all site content:

```php
$this->pages()                          // all pages
$this->regularPages()                   // pages without a content type
$this->section('blog')                  // pages under the blog/ path prefix
$this->type('blog')                     // pages with content type 'blog'
$this->taxonomyTerm('tags', 'php')      // pages tagged 'php'
$this->isCurrent('/blog/')              // bool
$this->previousInSection()             // ?ContentPage
$this->nextInSection()                 // ?ContentPage
$this->extension('name')               // call a project extension (see Extensions)
```

See [Page collections](page-collections.dj) for filtering, sorting, grouping, and pagination. For custom PHP logic callable from templates, see [Extensions](extensions.dj).

### Navigation example (grouped sidebar)

This pattern builds a nested docs navigation from frontmatter keys like `group`, `weight`, `navigation`, and `navigationTitle`.

```php
<?php
$pages = $this->pages()->by('weight', 'asc')->filter(
    static fn(\Glaze\Content\ContentPage $p): bool => (bool)($p->meta('navigation') ?? true),
);
$grouped = $pages->filter(
    static fn(\Glaze\Content\ContentPage $p): bool => trim((string)($p->meta('group') ?? '')) !== '',
)->groupBy('group');
$other = $pages->filter(
    static fn(\Glaze\Content\ContentPage $p): bool => trim((string)($p->meta('group') ?? '')) === '',
);
?>

<ul class="menu bg-base-200 rounded-box w-56">
    <?php foreach ($grouped as $groupName => $groupPages): ?>
        <li>
            <h2 class="menu-title"><?= $groupName ?></h2>
            <ul>
                <?php foreach ($groupPages as $item): ?>
                    <li>
                        <a
                            href="<?= ($site->basePath ?? '') . $item->urlPath ?>"
                            s:class="['menu-active' => $this->isCurrent($item->urlPath)]"
                        >
                            <?= $item->meta('navigationTitle', $item->title) ?>
                        </a>
                    </li>
                <?php endforeach; ?>
            </ul>
        </li>
    <?php endforeach; ?>

    <?php if (count($other) > 0): ?>
        <li>
            <h2 class="menu-title">Other</h2>
            <ul>
                <?php foreach ($other as $item): ?>
                    <li><a href="<?= ($site->basePath ?? '') . $item->urlPath ?>"><?= $item->title ?></a></li>
                <?php endforeach; ?>
            </ul>
        </li>
    <?php endif; ?>
</ul>
```

## Sugar directives

Sugar provides attribute-based directives for control flow, looping, and conditional class merging. A brief example:

```php
<!-- loop -->
<li s:foreach="$this->section('blog')->take(5) as $post">
    <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
</li>

<!-- conditional -->
<span s:if="$page->draft">Draft</span>
<span s:else>Published</span>

<!-- conditional class -->
<a href="<?= $post->urlPath ?>" s:class="['active' => $this->isCurrent($post->urlPath)]">
    <?= $post->title ?>
</a>
```

For the complete directive reference -- including `s:unless`, `s:forelse`, `s:switch`, `s:isset`, loop metadata (`$loop->first`, `$loop->last`), components, and the pipe syntax -- see the [Sugar documentation](https://josbeir.github.io/sugar/).

## Vite template integration (`s:vite`)

When Vite is enabled in Glaze config, Sugar's Vite extension is automatically registered and you can render dev/prod asset tags directly from templates.

Basic usage:

```php
<s-template s:vite="'assets/css/site.css'" />
```

Multiple entries:

```php
<s-template s:vite="['assets/css/site.css', 'assets/js/site.js']" />
```

Default entry (from `build.vite.defaultEntry` or `devServer.vite.defaultEntry`):

```php
<s-template s:vite="true" />
```

Behavior by mode:

- `glaze serve --vite` (live mode): emits dev server tags (`@vite/client` + module entry tags)
- `glaze build` with `build.vite.enabled: true`: resolves and emits production tags from Vite manifest

To scaffold all related files/config quickly:

```bash
glaze init my-site --vite
```

## Debug helpers

Available in all templates:

- `dump(...)` -- formatted variable dump
- `debug(...)` -- alias for `dump`
- `dd(...)` -- dump and die

Output is rendered in a styled `<pre>` block when served via `glaze serve`.
