---
title: Page Collections
weight: 90
---
# Page collections

Page collections are Glaze's query-friendly wrapper around all discovered pages. You access them through `$this` (the `SiteContext` object) inside [Sugar](https://josbeir.github.io/sugar/) templates.

Collections are lazy and chainable -- call as many methods as you need before iterating.

## Accessing collections

```php
$this->pages()                         // all pages
$this->regularPages()                  // pages without a content type
$this->section('blog')                 // pages under the blog/ path prefix
$this->type('blog')                    // pages with content type 'blog'
$this->taxonomyTerm('tags', 'php')     // pages tagged 'php'
```

## `ContentPage` properties

Every item in a collection is a `ContentPage` object:

```php
$page->title            // string
$page->urlPath          // string -- e.g. /blog/my-post/
$page->slug             // string -- e.g. blog/my-post
$page->relativePath     // string -- e.g. blog/my-post.dj
$page->draft            // bool
$page->type             // ?string -- content type name
$page->meta             // array<string, mixed> -- all frontmatter metadata
$page->taxonomies       // array<string, array<string>> -- e.g. ['tags' => ['php', 'oss']]
```

Access custom frontmatter values via `$page->meta`:

```php
$page->meta['date']          // Chronos instance (when set)
$page->meta['description']   // string (when set)
$page->meta['weight']        // int (when set)
$page->meta['featured']      // bool (when set)
```

## Iterating

```php
<ul>
    <li s:foreach="$this->section('blog')->take(5) as $post">
        <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
    </li>
</ul>
```

## Common helpers

- `count()` -- total number of pages in collection
- `first()` -- first page or null
- `last()` -- last page or null
- `take(n)` -- first n pages
- `slice(offset, length)` -- a range of pages
- `reverse()` -- reverse the current order

## Sorting

```php
// by any dot-path key
$this->pages()->by('meta.weight', 'asc')

// by date field
$this->section('blog')->byDate('desc')                    // uses meta.date by default
$this->section('blog')->byDate('desc', 'meta.published')  // custom date field

// alphabetically
$this->pages()->byTitle('asc')
```

## Filtering with `where`

`where` takes a dot-path key, an optional operator, and a value. When the operator is omitted, `=` is assumed.

Supported operators:

- equality: `=`, `==`, `eq`
- inequality: `!=`, `<>`, `ne`
- comparisons: `>`, `>=`, `<`, `<=`
- set membership: `in`, `not in`
- intersection: `intersect`
- pattern match: `like`

```php
// pages marked as featured
$this->where($this->pages(), 'meta.featured', true)

// pages with weight >= 10
$this->where($this->pages(), 'meta.weight', '>=', 10)

// pages tagged with either 'php' or 'oss'
$this->where($this->pages(), 'meta.tags', 'intersect', ['php', 'oss'])
```

## Type helpers

```php
// via site context
$this->type('docs')

// via collection method
$this->pages()->whereType('docs')

// chained
$this->type('blog')->byDate('desc')->take(5)
```

## Grouping

```php
// group by an arbitrary key
$this->pages()->groupBy('meta.category')
$this->pages()->groupBy('meta.category', 'asc')   // optional: sort group keys ascending
$this->pages()->groupBy('meta.category', 'desc')  // optional: sort group keys descending

// group by date period
$this->section('blog')->groupByDate('Y-m', 'desc')                    // uses meta.date
$this->section('blog')->groupByDate('Y', 'desc', 'meta.published')   // custom date field
```

A grouped collection is a plain array where keys are group names and values are `PageCollection` instances:

```php
<section s:foreach="$this->section('blog')->groupByDate('Y-m', 'desc') as $month => $pages">
    <h2><?= $month ?></h2>
    <ul>
        <li s:foreach="$pages as $post">
            <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
        </li>
    </ul>
</section>
```

### Navigation recipe (section-based menu)

Glaze derives sections from the content folder structure. Place pages inside subfolders and they automatically belong to that section. Use `$this->sections()` and `$this->sectionLabel()` for clean sidebar navigation:

```php
<ul class="menu">
    <li s:foreach="$this->sections() as $sectionKey => $sectionPages">
        <h2 class="menu-title"><?= $this->sectionLabel($sectionKey) ?></h2>
        <ul>
            <template s:foreach="$sectionPages as $item">
                <li s:if="$item->meta('navigation') ?? true">
                    <a href="<?= $item->urlPath ?>">
                        <?= $item->meta('navigationTitle') ?? $item->title ?>
                    </a>
                </li>
            </template>
        </ul>
    </li>
</ul>
```

Sections are ordered by the lowest `weight` value among their pages.
The label is auto-humanized from the folder name (`getting-started` becomes `Getting Started`).

Shorthand metadata keys are supported in collection queries:

```php
$pages->groupBy('category');
$pages->groupBy('category', 'desc');
$pages->by('weight', 'asc');
```

## Pagination

```php
<?php $pager = $this->paginate($this->section('blog'), 10, 1, '/blog/'); ?>

<ul>
    <li s:foreach="$pager->items() as $post">
        <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
    </li>
</ul>

<nav>
    <a s:if="$pager->hasPrev()" href="<?= $pager->prevUrl() ?>">Previous</a>
    <a s:if="$pager->hasNext()" href="<?= $pager->nextUrl() ?>">Next</a>
</nav>
```

Arguments: `paginate(collection, perPage, currentPage, baseUrl)`.

## Previous / next navigation

Navigate across section boundaries in global display order:

```php
<?php $prev = $this->previous(); ?>
<?php $next = $this->next(); ?>

<nav>
    <a s:if="$prev !== null" href="<?= $prev->urlPath ?>">&larr; <?= $prev->title ?></a>
    <a s:if="$next !== null" href="<?= $next->urlPath ?>"><?= $next->title ?> &rarr;</a>
</nav>
```

To navigate within the current section only, use `previousInSection()` / `nextInSection()`:

```php
<?php $prev = $this->previousInSection(); ?>
<?php $next = $this->nextInSection(); ?>
```

## Checking the current page

```php
<a
    href="<?= $post->urlPath ?>"
    s:class="['active' => $this->isCurrent($post->urlPath)]"
>
    <?= $post->title ?>
</a>
```

