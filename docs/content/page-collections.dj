---
title: Page Collections
weight: 90
group: Templating
---
# Page collections

Page collections are Glaze's query-friendly wrapper around all discovered pages. You access them through `$this` (the `SiteContext` object) inside [Sugar](https://josbeir.github.io/sugar/) templates.

Collections are lazy and chainable -- call as many methods as you need before iterating.

## Accessing collections

```php
$this->pages()                         // all pages
$this->regularPages()                  // pages without a content type
$this->section('blog')                 // pages under the blog/ path prefix
$this->type('blog')                    // pages with content type 'blog'
$this->taxonomyTerm('tags', 'php')     // pages tagged 'php'
```

## `ContentPage` properties

Every item in a collection is a `ContentPage` object:

```php
$page->title            // string
$page->urlPath          // string -- e.g. /blog/my-post/
$page->slug             // string -- e.g. blog/my-post
$page->relativePath     // string -- e.g. blog/my-post.dj
$page->draft            // bool
$page->type             // ?string -- content type name
$page->meta             // array<string, mixed> -- all frontmatter metadata
$page->taxonomies       // array<string, array<string>> -- e.g. ['tags' => ['php', 'oss']]
```

Access custom frontmatter values via `$page->meta`:

```php
$page->meta['date']          // Chronos instance (when set)
$page->meta['description']   // string (when set)
$page->meta['weight']        // int (when set)
$page->meta['featured']      // bool (when set)
```

## Iterating

```php
<ul>
    <li s:foreach="$this->section('blog')->take(5) as $post">
        <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
    </li>
</ul>
```

## Common helpers

- `count()` -- total number of pages in collection
- `first()` -- first page or null
- `last()` -- last page or null
- `take(n)` -- first n pages
- `slice(offset, length)` -- a range of pages
- `reverse()` -- reverse the current order

## Sorting

```php
// by any dot-path key
$this->pages()->by('meta.weight', 'asc')

// by date field
$this->section('blog')->byDate('desc')                    // uses meta.date by default
$this->section('blog')->byDate('desc', 'meta.published')  // custom date field

// alphabetically
$this->pages()->byTitle('asc')
```

## Filtering with `where`

`where` takes a dot-path key, an optional operator, and a value. When the operator is omitted, `=` is assumed.

Supported operators:

- equality: `=`, `==`, `eq`
- inequality: `!=`, `<>`, `ne`
- comparisons: `>`, `>=`, `<`, `<=`
- set membership: `in`, `not in`
- intersection: `intersect`
- pattern match: `like`

```php
// pages marked as featured
$this->where($this->pages(), 'meta.featured', true)

// pages with weight >= 10
$this->where($this->pages(), 'meta.weight', '>=', 10)

// pages tagged with either 'php' or 'oss'
$this->where($this->pages(), 'meta.tags', 'intersect', ['php', 'oss'])
```

## Type helpers

```php
// via site context
$this->type('docs')

// via collection method
$this->pages()->whereType('docs')

// chained
$this->type('blog')->byDate('desc')->take(5)
```

## Grouping

```php
// group by an arbitrary key
$this->pages()->groupBy('meta.category')
$this->pages()->groupBy('meta.category', 'asc')   // optional: sort group keys ascending
$this->pages()->groupBy('meta.category', 'desc')  // optional: sort group keys descending

// group by date period
$this->section('blog')->groupByDate('Y-m', 'desc')                    // uses meta.date
$this->section('blog')->groupByDate('Y', 'desc', 'meta.published')   // custom date field
```

A grouped collection is a plain array where keys are group names and values are `PageCollection` instances:

```php
<section s:foreach="$this->section('blog')->groupByDate('Y-m', 'desc') as $month => $pages">
    <h2><?= $month ?></h2>
    <ul>
        <li s:foreach="$pages as $post">
            <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
        </li>
    </ul>
</section>
```

### Navigation recipe (grouped menu)

For docs sidebars, combine `weight`, `group`, `navigation`, and `navigationTitle` frontmatter values:

```php
<?php
$pages = $this->pages()->by('weight', 'asc')->filter(
    static fn(\Glaze\Content\ContentPage $p): bool => (bool)($p->meta('navigation') ?? true),
);

$grouped = $pages->filter(
    static fn(\Glaze\Content\ContentPage $p): bool => trim((string)($p->meta('group') ?? '')) !== '',
)->groupBy('group');

$other = $pages->filter(
    static fn(\Glaze\Content\ContentPage $p): bool => trim((string)($p->meta('group') ?? '')) === '',
);
?>

<ul class="menu bg-base-200 rounded-box w-56">
    <?php foreach ($grouped as $groupName => $groupPages): ?>
        <li>
            <h2 class="menu-title"><?= $groupName ?></h2>
            <ul>
                <?php foreach ($groupPages as $item): ?>
                    <li>
                        <a href="<?= $item->urlPath ?>">
                            <?= $item->meta('navigationTitle', $item->title) ?>
                        </a>
                    </li>
                <?php endforeach; ?>
            </ul>
        </li>
    <?php endforeach; ?>

    <?php if (count($other) > 0): ?>
        <li>
            <h2 class="menu-title">Other</h2>
            <ul>
                <?php foreach ($other as $item): ?>
                    <li><a href="<?= $item->urlPath ?>"><?= $item->title ?></a></li>
                <?php endforeach; ?>
            </ul>
        </li>
    <?php endif; ?>
</ul>
```

Because shorthand metadata keys are supported in collection queries, this is valid too:

```php
$pages->groupBy('group');
$pages->groupBy('group', 'desc');
$pages->by('weight', 'asc');
```

## Pagination

```php
<?php $pager = $this->paginate($this->section('blog'), 10, 1, '/blog/'); ?>

<ul>
    <li s:foreach="$pager->items() as $post">
        <a href="<?= $post->urlPath ?>"><?= $post->title ?></a>
    </li>
</ul>

<nav>
    <a s:if="$pager->hasPrev()" href="<?= $pager->prevUrl() ?>">Previous</a>
    <a s:if="$pager->hasNext()" href="<?= $pager->nextUrl() ?>">Next</a>
</nav>
```

Arguments: `paginate(collection, perPage, currentPage, baseUrl)`.

## Previous / next navigation

These helpers work relative to the current page's section:

```php
<?php $prev = $this->previousInSection(); ?>
<?php $next = $this->nextInSection(); ?>

<nav>
    <a s:if="$prev !== null" href="<?= $prev->urlPath ?>">&larr; <?= $prev->title ?></a>
    <a s:if="$next !== null" href="<?= $next->urlPath ?>"><?= $next->title ?> &rarr;</a>
</nav>
```

## Checking the current page

```php
<a
    href="<?= $post->urlPath ?>"
    s:class="['active' => $this->isCurrent($post->urlPath)]"
>
    <?= $post->title ?>
</a>
```

